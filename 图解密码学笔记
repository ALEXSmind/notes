图解密码技术笔记
---------------

v0.1 2019.3.16 Sherlock init
v0.1 2019.4.14 Sherlock add RSA

这篇文章是《图解密码技术》的读书笔记。希望没有密码技术背景的人或是没有读过这本
书的人通过这篇文章迅速建立起密码技术的基本概念。

各种密码技术就是用来保密，我们从具体的场景看起, 然后引出各种应对的手段。

1. 监听
-------
```
      +-----+               +-----+
      |  A  |------+------> |  B  |
      +-----+      |        +-----+
                   v
                 +-----+
                 |  C  |
                 +-----+
```
比如A发送信息给B，可能有C在链路上监听。应对的方法就是对要发送的信息加密, 比如我
们可以把发送的信息码字都加上1，B减去1就得到A原来发送的信息。这里就引入了密码学
上的几个基本概念, 这里对发送的信息加密就是原来的信息和额外的信息做运算，我们把
额外的信息叫做秘钥，把所做的运算叫做加解密算法。秘钥一般是不公开的，对于加解密
算法，有公开的算法，也有商业公司自己保密的算法，不过公开的算法的安全性要大大高于
私有的算法，现在一般的做法也是密码相关的行业组织会公开征集特定用途的算法，大家
通过竞争选出最好的算法。

可以看到上面的例子中，A用来加密的秘钥和B用来解密的秘钥是一样的。这种加解密的
方法叫对称加解密。实际使用中，秘钥和加解密算法是很复杂的，C即使听到了加密信息，
没有秘钥也解不出A发出的信息。

但是这样的加解密方法有一个要解决的问题: 怎么把一样的秘钥分发给A和B(前面我们已经
提到算法是公开的)。A直接传给B显然是不靠谱的，因为C完全可以听到。引入第三方，也不
靠谱，只要传输，C就可以听到秘钥。

为了应对是上面的问题，人们发明了非对称加解密。也就是说A用来加密的秘钥和B用来解密
的秘钥不是同一个。对称加解密使用的方法就是: 把加密秘钥发给对方，请对方用这个加密
秘钥加密信息, 解密秘钥自己留着，用来解密信息。下面的图是基本流程:
```
      +-----+                      +-----+
      |  A  |--------------------->|  B  |
      +-----+                      +-----+

                +-------+
                |pub key|  --> 
      +-----+   +-------+          +-----+
      |  A  |--------------------->|  B  |
      +-----+                      +-----+     +-------+   +---+
                                               |message| + |key| --+
                  +--------------+             +-------+   +---+   |
               <--|crypto message| <-------------------------------+
      +-----+     +--------------+ +-----+
      |  A  |--------------------->|  B  |
      +-----+                      +-----+

      
     +--------+   +--------------+
     |priv key| + |crypto message|     
     +--------+ | +--------------+
                v
     +-----------------+
     |message sent by B|
     +-----------------+
```
可以看到C即使听到pub key也没有用，因为pub key是用来给发给A的信息加密的。上面又
有几个新的概念，公钥是可以公开的秘钥，私钥必须保密。

我们平时用的ssh用的就是非对称加密, 和上面的模型是可以对上的。非对称加密解决了
对称加密里对称秘钥分发的问题，我们可以使用非对称加解密代替对称加解密。当然，我们
也可以一开始采用非对称加解密解决对称加解密秘钥分发的问题，然后就可以使用对称
加解密了。

可以看到，非对称加解密的缺点是C可以拿到给A发信息用的加密秘钥。这样C可以把自己的
公钥发给B，诱导B用C的公钥加密信息，这样C监听B发给A的信息，就可以用C自己的私钥
解密信息。为了解决这个问题，就需要B可以确认他收到的是A的公钥。(to do: how to do)

非对称加解密还有一个缺点，就是秘钥生成和加解密都需要很大的算里。所以很适合做专门
的硬件加速器去offload cpu资源。

这里可以看下RSA算法步骤，RSA算法是经典的非对称加解密算法。我们这里只简单罗列RSA
算法的步骤，因为他表现的很简单有趣。这里E和N为加密秘钥，D和N为解密秘钥。加密和
解密做的运算就是:
```
                   E                            D
	密文 = 明文  mod N           明文 = 密文  mod N
```
是不是很简单? 上面的密文和明文都是数字，加解密完全是一个求幂然后取模运算。但是
E, D是一个很大的数，大到用二进制表示，需要512bit，1024bit，2048bit，4096bit...
不同秘钥长度，当然密码的强度是不一样的。

E, D, N生成的算法是：

  1. 找两个很大的素数p, q

  2. N = p × q

  3. L = 最小公倍数(p - 1, q - 1)

  4. E为和L互质的数 ---> (E, N)是加密秘钥，公钥

  5. (E × D) mod L = 1, 求出D ---> (D, N)是解密秘钥，私钥

第2,5步的逆运算在数学上很困难，这个是RSA算法保密的根本。

2. 篡改
-------
```
      +-----+                      +-----+
      |  A  |------+  +----------->|  B  |
      +-----+      |  |            +-----+
                   v  |
                 +----++
                 |  C  |
                 +-----+
```
相比较上面的被动攻击，C还可以篡改A发给B的数据，然后发给B(其实上面也提到了主动
攻击, 我们先从简单的说起)。为了应对这样的攻击，B需要有办法验证收到信息的完整性。
一般用单向散列得到A发出信息的hash码，然后A把这个hash码也发给B，B对收到的信息做
同样的单向散列，把得到的hash码和收到的hash作对比，从而验证信息的完整性。

这要的算法有SHA3, MD5等。其实，一般我们发送大文件的时候，用md5sum算文件hash码,
然后在对接收到的文件做校验，就是一样的道理。

单向散列算法需要保证的就是防止碰撞发生，简单说就是不同数据得到的hash码要不一样。

单向散列只是单纯的验证数据的完整性，并不能确认数据就是A发出的。C可以把A发给B的
数据和hash值都截获，修改数据，然后对修改后的数据做下单向散列，然后把修改的数据
和新生成的hash值发给B。

3. 认证
-------
```
      +-----+                      +-----+
      |  A  |--------------------> |  B  |
      +-----+       +------------> +-----+
                    |
                 +--+--+
                 |  C  |
                 +-----+
```
如上，C也做下单向散列，然后把正确的hash码发送给B。B需要有办法确认他收到信息是A
发给他的，而不是别人伪造的。这里的问题和上面非对称加解密里C把自己的公钥发给B是
一样的问题。

当A，B有共享秘钥的时候，解决这个问题的方法是，信息和共享秘钥一起做单向散列。
但是非对称加密公钥配送的问题还是没有解决

对上面认证, 也叫消息认证码的攻击: 重放攻击

消息认证码无法解决的问题: 对第三方证明，防止否认。对第三方证明比较好理解, 共享
秘钥存在于A和B，第三方的机构无法证明信息是A向B发的。防止否认的意思是, B也无法证
明A确实向B发了一条消息。其中的关键是消息认证码用的是共享秘钥, 比如A向B发了一个信
息说向B借了10万元钱(相当于A给B写了一个欠条)，这个信息用消息认证码加密, 当B拿着这
个消息向A去索要钱的时候，A完全可以否认自己发过这个消息，因为B也有A一样的秘钥，完
全是可以自己制造这个消息出来的。为了解决A否认消息是他发出的，就要引入数字签名，
就是给自己发出的信息签上自己的名字。

4. 签名
-------

如何给自己发出的消息上标记上自己无法否认的信息？签名可以用非对称加解密的相反运算
实现: 用私钥加密信息给信息签名，用公钥解密加密的信息做验证。

针对签名的攻击:

5. 公钥证书
-----------

上面的各种办法其实还是没有办法解决非对称加解密里公钥配送的问题。

引入第三方机构办法公钥证书。

6. 秘钥
-------


7. 随机数
---------

8. PGP
------

9. SSL/TSL
----------

10. 区块链
----------

11. 硬件
--------

 SEC, HPRE, ZIP, RDE, TRNG, DMA
