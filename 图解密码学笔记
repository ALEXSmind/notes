图解密码技术笔记
---------------

v0.1 2019.3.16 Sherlock init

这篇文章是《图解密码技术》的读书笔记。希望没有密码技术背景的人或是没有读过这本
书的人通过这篇文章迅速建立起密码技术的基本概念。

各种密码技术就是用来保密，我们从具体的场景看起, 然后引出各种应对的手段。

1. 监听
-------
```
      +-----+               +-----+
      |  A  |------+------> |  B  |
      +-----+      |        +-----+
                   v
                 +-----+
                 |  C  |
                 +-----+
```
比如A发送信息给B，可能有C在链路上监听。应对的方法就是对要发送的信息加密, 比如我
们可以把发送的信息码字都加上1，B减去1就得到A原来发送的信息。这里就引入了密码学
上的几个基本概念, 这里对发送的信息加密就是原来的信息和额外的信息做运算，我们把
额外的信息叫做秘钥，把所做的运算叫做加解密算法。秘钥一般是不公开的，对于加解密
算法，有公开的算法，也有商业公司自己保密的算法，不过公开的算法的安全性要大大高于
私有的算法，现在一般的做法也是密码相关的行业组织会公开征集特定用途的算法，大家
通过竞争选出最好的算法。

可以看到上面的例子中，A用来加密的秘钥和B用来解密的秘钥是一样的。这种加解密的
方法叫对称加解密。实际使用中，秘钥和加解密算法是很复杂的，C即使听到了加密信息，
没有秘钥也解不出A发出的信息。

但是这样的加解密方法有一个要解决的问题: 怎么把一样的秘钥分发给A和B(前面我们已经
提到算法是公开的)。A直接传给B显然是不靠谱的，因为C完全可以听到。引入第三方，也不
靠谱，只要传输，C就可以听到秘钥。

为了应对是上面的问题，人们发明了非对称加解密。也就是说A用来加密的秘钥和B用来解密
的秘钥不是同一个。对称加解密使用的方法就是: 把加密秘钥发给对方，请对方用这个加密
秘钥加密信息, 解密秘钥自己留着，用来解密信息。下面的图是基本流程:
```
      +-----+                      +-----+
      |  A  |--------------------->|  B  |
      +-----+                      +-----+

                +-------+
                |pub key|  --> 
      +-----+   +-------+          +-----+
      |  A  |--------------------->|  B  |
      +-----+                      +-----+     +-------+   +---+
                                               |message| + |key| --+
                  +--------------+             +-------+   +---+   |
               <--|crypto message| <-------------------------------+
      +-----+     +--------------+ +-----+
      |  A  |--------------------->|  B  |
      +-----+                      +-----+

      
     +--------+   +--------------+
     |priv key| + |crypto message|     
     +--------+ | +--------------+
                v
     +-----------------+
     |message sent by B|
     +-----------------+
```
可以看到C即使听到pub key也没有用，因为pub key是用来给发给A的信息加密的。上面又
有几个新的概念，公钥是可以公开的秘钥，私钥必须保密。

我们平时用的ssh用的就是非对称加密, 和上面的模型是可以对上的。非对称加密解决了
对称加密里对称秘钥分发的问题，我们可以使用非对称加解密代替对称加解密。当然，我们
也可以一开始采用非对称加解密解决对称加解密秘钥分发的问题，然后就可以使用对称
加解密了。(to do: why)

可以看到，非对称加解密的缺点是C可以拿到给A发信息用的加密秘钥。
(to do: 这样有何缺点, 如何解决?)
	
(to do: 计算量和硬件offload)

2. 篡改
-------
```
      +-----+                      +-----+
      |  A  |------+  +----------->|  B  |
      +-----+      |  |            +-----+
                   v  |
                 +----++
                 |  C  |
                 +-----+
```
相比较上面的被动攻击，C还可以篡改A发给B的数据，然后发给B。为了应对这样的攻击，
B需要有办法验证收到信息的完整性。一般用单向散列的到A发出信息的hash码，然后A把
这个hash码也发给B，B对收到的信息做同样的单向散列，把得到的hash码和收到的hash作
对比，从而验证信息的完整性。

(to do: 如何避免C也做下单向散列，然后把正确的hash码发送给B?)


3. 认证
-------
```
      +-----+                      +-----+
      |  A  |--------------------> |  B  |
      +-----+       +------------> +-----+
                    |
                 +--+--+
                 |  C  |
                 +-----+
```
如上，C也做下单向散列，然后把正确的hash码发送给B。B需要有办法确认他收到信息是A
发给他的，而不是别人伪造的。

