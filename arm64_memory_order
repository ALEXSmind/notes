ARM64 内存屏障
--------------

-v0.1 2018/5/21 Sherlock init


 本文试图梳理aarch64构架下的内存屏障的逻辑，细节的东西还要去看ARMv8的手册。其实，
 <<ARM Cortex-A Series Programmer’s Guide for ARMv8-A>>这本书的第13章，memory
 order已经对内存屏障的内容做了比较入门的讲解。

 要理解内存屏障，要知道memory的一些特性，这里的memory不是只指内存。而是从CPU角度
 看到的存储空间。如果CPU对一系列的指令执行是严格串行的，我们是不用外加上面内存
 屏障的。比如：

 	str x1 [x2]   // A
	str x2 [x3]   // B

 A指令完全执行完，B指令才执行。这样根本不需要内存屏障指令的介入。

 但是现在处理器和内存系统之间的速度差距已经非常大，如果要上面的A执行完成才执行B
 cpu要消耗大量的时间干等在那里。为了缓解CPU和内存系统间的速度差距，同时也为了不断
 提升CPU的效率，现代CPU存在很多指令执行上的技术，导致的结果是指令执行的结果和之前
 的逻辑已经不一样了。

 CPU上存在着多种指令执行的技术，其中导致需要加上内存屏障执行的是CPU上的指令乱序
 执行。

 为了解释清楚CPU执行乱序执行需要引入两个基本的概念，一个是内存类型(memory type),
 另外一个是master/slave. 内存类型定义的CPU和内存相互作用时的一些性质，内存类型
 只有normal和device两种, normal基本上可以对应DDR，device

