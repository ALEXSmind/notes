gic its note
============

-v0.1 2015.9.5   Sherlock init
-v0.2 2015.9.8   Sherlock add v4.2 ITS analysis
-v0.3 2015.9.21  Sherlock add how to build up basic gic lpi
-v0.4 2015.10.14 Sherlock add different part number, add part 2

1. current GIC ITS code in v4.2/v4.3
------------------------------------

/* this is the arch of interrupt sub-system */
struct irq_desc
    --> struct irq_data
        --> struct irq_chip
        --> struct irq_domain
            --> struct irq_domain_ops

/* this is the arch of ITS sub-system, for v4.1, for v4.2, kernel changed a lot */
struct its_node
    --> struct irq_domain
        --> struct irq_domain_ops (its_domain_ops)
	        /* alloc put struct irq_chip (its_irq_chip) to related
		 * struct irq_data
		 *
		 * Fix me for other work alloc does
		 */
	    --> .alloc (its_irq_domain_alloc)
	    --> .activate (its_irq_domain_activate)
	    --> ...
    --> struct msi_controller
            /* father irq_domain is irq_domain above */
        --> struct irq_domain
	        /* msi_domain_ops defined in kernel/irq/msi.c */
	    --> struct irq_domain_ops (struct irq_domain_ops msi_domain_ops)
	    --> void *host_data (struct msi_domain_info its_pci_msi_domain_info)
                --> struct msi_domain_ops (its_pci_msi_ops)
                    --> .msi_prepare (its_msi_prepare)
                    --> ...
                --> struct irq_chip (its_msi_irq_chip)

/* this is the arch of ITS sub-system for v4.2, ITS driver changed a lot in v4.2 */
there is no irq_domain in struct its_node. In drivers/irqchip/irq-gic-v3-its.c,
just build up below irq_domain.

		gic irq_domain --> irq_domain_ops(gic_irq_domain_ops)
		      ^                --> .alloc(gic_irq_domain_alloc)
		      |
		its irq_domain --> irq_domain_ops(its_domain_ops)
		      ^                --> .alloc(its_irq_domain_alloc)
		      |                --> ...
		      |        --> host_data(struct msi_domain_info)
		      |            --> msi_domain_ops(its_msi_domain_ops)
		      |                --> .msi_prepare(its_msi_prepare)
		      |            --> irq_chip, chip_data, handler...
		      |            --> void *data(struct its_node)

In drvers/irqchip/irq-gic-v3-its-pci-msi.c,
   drvers/irqchip/irq-gic-v3-its-platform-msi.c, it seems that we create two
other irq_domain:

pci_its irq_domain                      platform_its irq_domain
        /* kernel/irq/msi.c */                  /* kernel/irq/msi.c */
    --> irq_domain_ops(msi_domain_ops)      --> irq_domain_ops(msi_domain_op)
        /* irq-gic-v3-its-pci-msi.c             /* irq-gic-v3-its-platform-msi.c
	 * (its_pci_msi_domain_info)             * (its_pmsi_domain_info)
	 */                                      */
    --> void *host_data                     --> void *host_data
        --> .ops(its_pci_msi_ops)               --> .ops(its_pmsi_ops)
	        /* its_pci_msi_prepare */   	    /* its_pmsi_prepare */
	    --> .msi_prepare                    --> .msi_prepare
	--> .chip(its_msi_irq_chip)             --> .chip(its_pmsi_irq_chip)

2. msi domain struct
--------------------

basic struct:

struct msi_domain_info
    --> struct msi_domain_ops
        --> .msi_prepare
    --> struct irq_chip
        --> .irq_write_msi_msg

pci_msi_create_irq_domain(device_node, msi_domain_info, parent)
        /* core function */
    --> msi_create_irq_domain(node, info, parent);
            /* msi_domain_ops is irq_domain_ops in kernel/irq/msi.c
             * info below will be stored in host_data of irq_domain
             *
             * both pci_its irq_domain and platform_its irq_domain use
             * same msi_domain_ops, but different msi_domain_info
             */
        --> irq_domain_add_hierarchy(parent, 0, 0, node, &msi_domain_ops, info)

3. pci msi struct 
-----------------

in part 2, it creats related domain, then we will see how to use callbacks
in above domain.

/* this is the work flow of PCI MSI */
/* kernel/drivers/pci/msi.c */
pci_msi_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
        /* so this irq_domain is pci_its irq_domain ? */
    --> pci_msi_domain_alloc_irqs(domain, dev, nvec, type);
        --> msi_domain_alloc_irqs(domain, &dev->dev, nvec);
	        /* should be its_pci_msi_prepare ?
                 * if below function, first get dev_id, then call parent domain
                 * msi_prepare which is its domain msi_prepare and will build
                 * up device table of ITS.
                 */
	    --> ps->msi_prepare(domain, dev, nvec, &arg);
	       /* domain, virq, desc->nvec_used, dev_to_node(dev), &arg, false */
	    --> __irq_domain_alloc_irqs()


/* details of how ITS work */
/* in pci_msi irq_domain */
its_pci_msi_prepare
    --> ... (get dev_ip)
        /* in its irq_domain */
    --> its_msi_prepare
        --> its_create_device(its, dev_id, nvec);

4. ITS hardware 
---------------

how to build up basic gic lpi:
gic_of_init
    --> gic_data.domain = irq_domain_add_tree(node, &gic_irq_domain_ops, &gic_data);
    --> its_init(node, &gic_data.rdists, gic_data.domain);
        --> its_probe(np, parent_domain);
            --> its_alloc_tables(node->full_name, its);
            --> its_alloc_collections(its);
            --> irq_domain_add_tree(node, &its_domain_ops, its);
        --> its_alloc_lpi_tables();
            --> gic_rdists->prop_page = alloc_pages()
        --> its_lpi_init(rdists->id_bits);
            --> lpi_bitmap = kzalloc()
    --> gic_cpu_init();
        --> its_cpu_init();
            --> its_cpu_init_lpis();
                --> gic_data_rdist()->pend_page = pend_page;
            --> its_cpu_init_collection();
                --> target = gic_data_rdist()->phys_base;
                --> its->collections[cpu].target_address = target;

a lot init configuration above: its, lpi, its_cpu

some hardware table:
--------------------
its device table
its ITT
its collection table
lpi pending table
lpi configure table

in its_alloc_tables, allocate its device table
it seems that there are its device table, collection GITS_BASERn, and reading
from GITS_TYPER, we can get how many device id this ITS support.

we assign 2^order size memory to its->table[i].
but why we assign alloc_size = (1 << order) * PAGE_SIZE to GITS_BASERn

/* easy one, just allocate its->collection memory */
its_alloc_collections

/* just allocate memory to gic_rdists->prop_page */
its_alloc_lpi_tables

/* GICD_TYPER 0x0004 [23:19] indicates how many lpi ?
 * one lpi one bit, so 32 lpi per lpi_chunk, and lpi_bitmap points to this map ?
 */
its_lpi_init

/* pend_page = gic_data_rdist()->pend_page, allocate pend table */
its_cpu_init_lpis
    /* write lpi config table to register GICR_PROPBASER */
    --> writeq_relaxed(val, rbase + GICR_PROPBASER)
    /* configure pend table pointer to register GICR_PENDBASER */
    --> writeq_relaxed(val, rbase + GICR_PENDBASER)

/* its_node indicates a physical ITS hardware */
struct its_node {
	raw_spinlock_t		lock;
	struct list_head	entry;
	void __iomem		*base;
	unsigned long		phys_base;
	/* cmd_base, cmd_write are command queue pointers */
	struct its_cmd_block	*cmd_base;
	struct its_cmd_block	*cmd_write;
	void			*tables[GITS_BASER_NR_REGS];
	struct its_collection	*collections;
	struct list_head	its_device_list;
	u64			flags;
	u32			ite_size;
};

/* its_device indicates a device which sends out MSI to an ITS */
struct its_device {
	struct list_head	entry;
	struct its_node		*its;
	struct event_lpi_map	event_map;
	void			*itt;
	u32			nr_ites;
	u32			device_id;
};



