Linux信号笔记
-------------

-v0.1 2019.7.7 Sherlock init

Linux中可以用信号来做通信，本文是对linux信号的一个使用总结。也会总结下APUE第10
章中关于信号的内容。

Linux里有进程，线程，基于此有进程组，线程组的概念。Linux内核把进程，线程做一样
的实现，都用一个task_struct表示, 这里我们统一用linux内核的概念来看待以上的概念。
内核include/linux/pid.h中对PID的种类有如下的定义:
```
enum pid_type
{
	PIDTYPE_PID,
	PIDTYPE_TGID,
	PIDTYPE_PGID,
	PIDTYPE_SID,
	PIDTYPE_MAX,
};
```
这里PID指的是一个内核线程ID，对应到用户态可以是一个进程或是一个线程。TGID指线程组
ID一个用户态进程和他创建的所有线程组成一个线程组。PGID是指进程组ID，这个要调用linux
系统函数创建，把多个用户态进程组成一个进程组。SID是指会话ID。

信号可以从一个用户态进程发到一个用户态进程，也可以从一个用户态线程发到一个用户态
线程。当然信号还可以从内核发到用户态，这里就涉及到上面PID的类型，通过指定不同的
PID类型, 内核可以把信号发到单个线程(进程)、线程组、进程组等。

信号是一种进程的系统资源, 而且传递时携带的信息很少。这样的性质决定，使用信号最好
由整个系统的顶层设计规划，不然如果底层设计中使用了信号, 很容易和其他的软件部件
相互冲突。因为信号传递的信息很少，必然要再加入其他的逻辑才可以完成整个业务逻辑，
这就会带来系统的复杂度。信号执行是打断原有进程(线程)执行流的，编写信号处理函数
要使用可重入函数，而且为了防止死锁，信号处理函数里不能使用锁，这些限制都使得信号
处理函数的编写很容易出错。

可以把信号处理从使用信号处理函数转变到使用线程，在线程中等待信号到来，然后处理。
这样可以把之前异步的处理放在线程里处理，避免上面说的信号处理函数里不能加锁的限制，
(fix me: 是否可以使用可重入函数)。但是这样的代价是...

https://www.ibm.com/developerworks/cn/linux/l-cn-signalsec/index.html

1. 线程处理信号的demo
2. 内核信号fasync
3. 内核信号send_sig_info
