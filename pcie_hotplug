linux PCIe hotplug arch analysis
================================

-v0.1 2016.9.6 sherlock init
-v0.2 2016.9.7 sherlock update except irq part
-v0.3 2016.9.8 sherlock update irq part
-v0.4 2016.9.9 sherlock update irq part


This analysis is based on v4.8-rc5.

There are two kinds of PCIe hotplug: one is PCIe native hotplug which is implemented
just used the codes in linux kernel, second is PCIe hotplug based on ACPI. Here
we just analyze the native hotplug.

PCIe hotplug is implemented as a pcie port service, it is registered in pcie port
driver in drivers/pci/hotplug/pciehp_core.c:
```
--> pcied_init(void)
    --> pcie_port_service_register(&hpdriver_portdrv)
```
so system will finally call pciehp_probe in struct pcie_port_service_driver hpdriver_portdrv,
main flow of this probe:
```
pciehp_probe(struct pcie_device *dev)
        /* create struct controller, struct slot, get slot capability and slot status info */
    --> pcie_init(dev);
        /* create struct hotplug_slot, struct hotplug_slot_info, struct hotplug_slot_ops,
         * fill functions in hotplug_slot_ops
         *
         *   controller
         *        +------> slot
         *                   +----> hotplug_slot
         *                               +-------> pci_slot
         *                                         hotplug_slot_ops
         *                                         hotplug_slot_info
         * then the whole structures will like above.
         *
         * After above structure been built, it will call pci_hp_register
         */
    --> init_slot(ctrl);
            /* add hotplug_slot into pci_hotplug_slot_list */
        --> pci_hp_register(hotplug, ctrl->pcie->port->subordinate, 0, name);
                /* to check: where to init pci_slot */
            --> pci_create_slot
            --> list_add(&slot->slot_list, &pci_hotplug_slot_list);
                /* expose pci_slot related file in sys-fs */
            --> fs_add_slot(pci_slot);
        /* register irq */
    --> pcie_init_notification(ctrl);
            /* when request_irq, will let struct controller to be its private data */
        --> pciehp_request_irq(ctrl)
            /* hardwar set here ?? enable some bits in slot control reg,
             *
             * here, in pcie_write_cmd function, we need wait former cmd finished,
             * if needed, we should check the details of this wait function.
             */
        --> pcie_enable_notification(ctrl);
        /* if there is a device on the slot */
    --> pciehp_enable_slot(slot);
            /* after check the status of device, if needed, will enable the device
             *
             * As we already implements linkup in UEFI, if we enable PCIe controller
             * driver, it will not call board_added. If we do not enable PCIe controller,
             * it will call board_added here.
             */
        --> board_added(struct slot *p_slot)
```

```
pcie_isr
        /* to check: where to define the handle of below queue */
    --> wake_up(&ctrl->queue);
        /* create related work_struct, then put work_struct to the work_queue in struct slot,
         * Here, we may have: Attention Button Pressed, Presence Detect Changed
         * Power Fault Detected, Link up/down check.
         *
         * same handle will be added to work_struct: interrupt_event_handler, 
         * in above function, it handle all cases.
         *
         * We can not analyze all cases, so here just pick up hot-insert and surprise
         * removal to analyze.
         *
         * when you analyze the different cases, please pay great attention on
         * struct slot -> state, which indicates the current status of hot-plug
         * state machine. And we should get clear the map between these state
         * and real physical state.
         */
    --> pciehp_queue_interrupt_event(slot, INT_BUTTON_PRESS);
```

The standard flow of hot-insert is:
1. pcie device hot insertion, trigger Presence Detect interrupt
```
       --> interrupt_event_handler: INT_PRESENCE_ON
           --> handle_surprise_event
                   /* if presence detect bit in slot status set 1 */
               --> pciehp_queue_power_work(..., ENABLE_REQ)
                       /* will create work_queue, and add it to struct slot's wq,
                        * the handler function is pciehp_power_thread
                        *
                        * above handler will be called by work queue in slot.
                        */
                   --> pciehp_power_thread: case ENABLE_REQ
                       --> pciehp_enable_slot(p_slot)
                               /* before doing this, we will check slot status */
                           --> board_added
                               --> pciehp_green_led_blink
                                       /* send green led blink */
                                   --> pcie_write_cmd_nowait
                                   /* check linkup, here maximum wait 1s */
                               --> pciehp_check_link_status
                                   /* to check resource assign if has problem */
                               --> pciehp_configure_device
                               --> pciehp_green_led_on
                       --> p_slot->state = STATIC_STATE;
```
   /* this is a litte wired, can not match the standard flow with the code here */
2. button pressed, trigger Attention Button Pressed interrupt
```
       --> interrupt_event_handler: INT_BUTTON_PRESS

```


pciehp_configure_device





note
----

struct slot -> state:



                         +-------------------+
                         | BLINKINGOFF_STATE |
                         +-------------------+




+--------------+ slot enable +------------+  slot disable +--------------+
|POWERON_STATE | ----------> |STATIC_STATE|  <----------- |POWEROFF_STATE|
+--------------+             +------------+               +--------------+




                          +----------------+
                          |BLINKINGON_STATE|
                          +----------------+




from PCIe spec, power indicator should be a green led:
off means power off, so we can insertion/removal
on means power on, so we can not insertion/removal
blinking means, it is powering up/down or a feedback from attention button pressed
                or hot-plug operation is initiated through software.


Reference
---------

1. PCI.EXPRESS系统体系结构标准教材].(美)Pavi.Budruk,Don.Anderson,Tom.Shanley.扫描版.pdf

